# Story 3.1: JWT Authentication & Session Management

## Status
Done

## Story
**As a** System User (Staff, Dentist, Manager, Admin, or Patient),
**I want** a secure login system using JWT tokens,
**so that** I can securely access the system with role-based permissions.

## Acceptance Criteria
1. Backend implements JWT token generation with 15-minute access token and 7-day refresh token expiry
2. Login endpoint (`POST /api/auth/login`) accepts username and password, returns tokens on success
3. Password verification uses bcrypt for secure hash comparison
4. Refresh endpoint (`POST /api/auth/refresh`) accepts refresh token and issues new token pair
5. Authentication middleware verifies JWT signature on protected routes
6. Invalid credentials return 401 Unauthorized with clear error message
7. User model stores hashed passwords using bcryptjs (minimum 10 salt rounds)
8. Tokens include user ID, role, and username in payload
9. Environment variables configure JWT_SECRET and JWT_REFRESH_SECRET
10. All authentication endpoints return consistent JSON response format
11. User model includes fields: id, username, password_hash, role, email, created_at, updated_at
12. Database migration creates users table with proper indexes on username and email

## Tasks / Subtasks

- [x] **Task 1: Create User Model and Migration** (AC: 7, 11, 12)
  - [x] Create Sequelize migration for users table
  - [x] Define fields: id (UUID primary key), username (unique, indexed), password_hash, role (enum), email (unique, indexed), created_at, updated_at
  - [x] Add indexes on username and email for query performance
  - [x] Run migration to create table in database

- [x] **Task 2: Implement User Sequelize Model** (AC: 7, 11)
  - [x] Create `backend/models/User.js` with Sequelize model definition
  - [x] Define model fields with proper data types and validation
  - [x] Add static method `hashPassword(password)` using bcryptjs with 10 salt rounds
  - [x] Add instance method `validatePassword(password)` for password verification
  - [x] Define role enum: ['admin', 'manager', 'dentist', 'staff', 'patient']
  - [x] Set up model associations if needed (none for this story)

- [x] **Task 3: Implement Authentication Controller** (AC: 1, 2, 3, 4, 6, 8, 10)
  - [x] Create `backend/controllers/authController.js`
  - [x] Implement `login` function:
    - [x] Validate username and password presence
    - [x] Find user by username
    - [x] Verify password using bcrypt.compare
    - [x] Return 401 for invalid credentials with message "Invalid credentials"
    - [x] Generate access token (15m expiry) with payload: { userId, username, role }
    - [x] Generate refresh token (7d expiry) with payload: { userId }
    - [x] Return JSON: { success: true, accessToken, refreshToken, user: { id, username, role, email } }
  - [x] Implement `refresh` function:
    - [x] Verify refresh token signature
    - [x] Extract userId from token
    - [x] Find user by ID
    - [x] Generate new access token and refresh token pair
    - [x] Return new tokens in same format as login

- [x] **Task 4: Create Authentication Middleware** (AC: 5, 6)
  - [x] Create `backend/middleware/authenticate.js`
  - [x] Implement `verifyToken` middleware:
    - [x] Extract token from Authorization header (Bearer format)
    - [x] Return 401 if no token provided
    - [x] Verify token signature using JWT_SECRET
    - [x] Return 401 for invalid/expired tokens
    - [x] Attach decoded user data to req.user
    - [x] Call next() on success
  - [x] Export middleware for use in protected routes

- [x] **Task 5: Configure Environment Variables** (AC: 9)
  - [x] Add JWT_SECRET to .env file (generate secure random string)
  - [x] Add JWT_REFRESH_SECRET to .env file (generate different secure random string)
  - [x] Document required environment variables in .env.example
  - [x] Ensure secrets are loaded via dotenv in server.js

- [x] **Task 6: Create Authentication Routes** (AC: 2, 4, 10)
  - [x] Create `backend/routes/authRoutes.js`
  - [x] Define POST /login route → authController.login
  - [x] Define POST /refresh route → authController.refresh
  - [x] Mount routes at `/api/auth` in main server.js
  - [x] Test routes with curl to verify JSON response format

- [x] **Task 7: Install Required Dependencies** (AC: 1, 3, 7)
  - [x] Install jsonwebtoken: `npm install jsonwebtoken`
  - [x] Install bcryptjs: `npm install bcryptjs`
  - [x] Verify dependencies in package.json

- [x] **Task 8: Create Seed Data for Testing** (AC: 2, 3, 6)
  - [x] Create database seed file to insert test users with hashed passwords
  - [x] Seed users for each role: admin, manager, dentist, staff, patient
  - [x] Document test credentials for development use
  - [x] Run seeder to populate test data

- [x] **Task 9: Testing and Validation**
  - [x] Test login with valid credentials → returns tokens and user data
  - [x] Test login with invalid username → returns 401
  - [x] Test login with invalid password → returns 401
  - [x] Test refresh endpoint with valid refresh token → returns new token pair
  - [x] Test refresh endpoint with invalid token → returns 401
  - [x] Test protected route with valid access token → allows access
  - [x] Test protected route with expired token → returns 401
  - [x] Test protected route without token → returns 401
  - [x] Verify password hashes are never returned in API responses
  - [x] Verify all error responses use consistent JSON format

## Dev Notes

### Previous Story Context
[Source: Story 2.4 Dev Agent Record]

Previous story (2.4) successfully implemented:
- express-validator middleware pattern for validation
- Structured error response format: `{ error: 'message', details: [...] }`
- API error handling with appropriate HTTP status codes (400 for validation, 500 for server errors)
- Winston logger for structured logging

**Key Learnings:**
- Middleware should run before controller logic in route definitions
- Validation middleware pattern works well for separation of concerns
- express-validator installed and working correctly

### Technology Stack
[Source: docs/architecture/2-technology-stack.md]

**Backend Authentication:**
- Runtime: Node.js 18 LTS or 20 LTS
- Framework: Express.js 4.x
- Auth: jsonwebtoken (JWT) + bcryptjs
- Validation: express-validator (already installed from Story 2.4)
- Database: MariaDB 10.6+ with Sequelize 6.x ORM
- Driver: mysql2

**Required npm packages (to install):**
- `jsonwebtoken` - JWT token generation and verification
- `bcryptjs` - Password hashing and comparison

### Authentication Architecture
[Source: docs/architecture/4-authentication-authentication-jwt-only.md]

**JWT Flow:**
1. **Login:**
   - Client sends `POST /api/auth/login` with `{ username, password }`
   - Backend verifies password hash using bcrypt
   - Backend issues `accessToken` (15m expiry) and `refreshToken` (7d expiry)
   - Tokens returned in JSON body

2. **Protected Requests:**
   - Client sends `Authorization: Bearer <accessToken>` header
   - Middleware verifies JWT signature
   - Decoded user data attached to req.user

3. **Refresh:**
   - Client sends `POST /api/auth/refresh` with `refreshToken`
   - Backend verifies and issues new token pair

**Auth Controller Pattern:**
```javascript
// backend/controllers/authController.js
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const { User } = require('../models');

exports.login = async (req, res) => {
  const { username, password } = req.body;

  // 1. Find User
  const user = await User.findOne({ where: { username } });
  if (!user) return res.status(401).json({ message: 'Invalid credentials' });

  // 2. Check Password
  const isMatch = await bcrypt.compare(password, user.password_hash);
  if (!isMatch) return res.status(401).json({ message: 'Invalid credentials' });

  // 3. Generate Tokens (15m access, 7d refresh)
  const accessToken = jwt.sign(
    { userId: user.id, username: user.username, role: user.role },
    process.env.JWT_SECRET,
    { expiresIn: '15m' }
  );

  const refreshToken = jwt.sign(
    { userId: user.id },
    process.env.JWT_REFRESH_SECRET,
    { expiresIn: '7d' }
  );

  // 4. Return tokens and user data (excluding password_hash)
  return res.status(200).json({
    success: true,
    accessToken,
    refreshToken,
    user: {
      id: user.id,
      username: user.username,
      role: user.role,
      email: user.email
    }
  });
};
```

### User Roles and Hierarchy
[Source: docs/prd/1-user-roles-access-hierarchy.md]

**Role Enumeration (for User model):**
- `admin` - System-Wide Control
- `manager` - Strategic/Oversight
- `dentist` - Clinical/Staff
- `staff` - Operational/Front Office
- `patient` - Self-Service

**Hierarchy:** Admin > Manager > Dentist > Staff > Patient

Higher roles inherit permissions of lower roles. This will be enforced in future stories with role-based middleware.

### Database Schema
[Source: Sequelize Model Pattern from Story 2.4]

**Users Table Schema:**
```javascript
{
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true
  },
  username: {
    type: DataTypes.STRING(50),
    allowNull: false,
    unique: true
  },
  password_hash: {
    type: DataTypes.STRING(255),
    allowNull: false
  },
  role: {
    type: DataTypes.ENUM('admin', 'manager', 'dentist', 'staff', 'patient'),
    allowNull: false,
    defaultValue: 'patient'
  },
  email: {
    type: DataTypes.STRING(100),
    allowNull: false,
    unique: true,
    validate: {
      isEmail: true
    }
  },
  created_at: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW
  },
  updated_at: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW
  }
}
```

**Indexes:**
- Primary key on `id`
- Unique index on `username`
- Unique index on `email`

### File Locations
[Source: Existing backend structure from Story 2.4]

**Backend File Structure:**
```
backend/
├── models/
│   ├── index.js (already exists - auto-loads models)
│   ├── AppointmentRequest.js (already exists)
│   └── User.js (NEW - create in this story)
├── migrations/
│   └── YYYYMMDDHHMMSS-create-users-table.js (NEW)
├── seeders/
│   └── YYYYMMDDHHMMSS-seed-test-users.js (NEW)
├── controllers/
│   ├── appointmentController.js (already exists)
│   └── authController.js (NEW)
├── middleware/
│   ├── validateAppointmentRequest.js (already exists)
│   └── authenticate.js (NEW)
├── routes/
│   ├── appointmentRoutes.js (already exists)
│   └── authRoutes.js (NEW)
├── utils/
│   └── logger.js (already exists - use for logging)
├── config/
│   └── config.js (already exists - database config)
├── .env (add JWT_SECRET, JWT_REFRESH_SECRET)
└── server.js (mount auth routes)
```

### Security Requirements
[Source: docs/prd/3-non-functional-requirements-nfrs.md]

**NFR S-SEC-003:** Access Control must be strictly enforced at the database/API level, not just the UI.
- JWT middleware will verify tokens before allowing access to protected routes
- Future stories will add role-based authorization middleware

**NFR S-SEC-002:** Data Encryption - All sensitive data must be encrypted at rest.
- Passwords MUST be hashed with bcryptjs (minimum 10 salt rounds)
- NEVER return password_hash in API responses
- Use bcrypt.compare for password verification (not manual comparison)

**NFR S-SEC-001:** Audit Logging - Track all user actions.
- Use Winston logger (already available from Story 2.4) to log authentication events
- Log successful logins, failed login attempts, token refreshes

### Environment Configuration
[Source: Backend setup from Story 2.4]

**Required .env variables:**
```
JWT_SECRET=<generate-secure-random-string-32-chars>
JWT_REFRESH_SECRET=<generate-different-secure-random-string-32-chars>
```

Use `crypto.randomBytes(32).toString('hex')` in Node.js to generate secure secrets.

### Error Response Format
[Source: Story 2.4 implementation]

**Consistent error format (follow existing pattern):**
```javascript
// Validation errors (400)
{
  error: 'Validation failed',
  details: [{ field: 'username', message: 'Username is required' }]
}

// Authentication errors (401)
{
  message: 'Invalid credentials'
}

// Server errors (500)
{
  message: 'An error occurred. Please try again later.'
}
```

### Testing Standards

**Testing Requirements:**
[Source: Backend testing pattern from Story 2.4]

Since Story 2.4 used manual curl testing for API validation, this story should follow the same pattern:

**Test with curl commands:**
1. Test login endpoint with valid credentials
2. Test login endpoint with invalid username
3. Test login endpoint with invalid password
4. Test refresh endpoint with valid refresh token
5. Test refresh endpoint with invalid/expired token
6. Test protected route with valid access token
7. Test protected route with expired access token
8. Test protected route without token

**Example curl commands:**
```bash
# Login test
curl -X POST http://localhost:3001/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"password123"}'

# Refresh test
curl -X POST http://localhost:3001/api/auth/refresh \
  -H "Content-Type: application/json" \
  -d '{"refreshToken":"<refresh_token_here>"}'

# Protected route test
curl -X GET http://localhost:3001/api/protected-resource \
  -H "Authorization: Bearer <access_token_here>"
```

**Log all test results using Winston logger format:**
- Log format: `YYYY-MM-DD HH:mm:ss [LEVEL]: Message { metadata }`
- Test both success and failure scenarios
- Verify no password hashes appear in logs

**No automated tests required for this story** - Manual testing with curl is sufficient per Story 2.4 pattern.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-13 | 1.0 | Initial story creation for Epic 3.1 | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be filled by Dev Agent_

### Debug Log References
_To be filled by Dev Agent_

### Completion Notes List
_To be filled by Dev Agent_

### File List
_To be filled by Dev Agent_

## QA Results
_To be filled by QA Agent_
